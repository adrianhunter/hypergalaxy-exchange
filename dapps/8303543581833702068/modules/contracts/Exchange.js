// Generated by LiveScript 1.5.0
(function(){
  var privateFoo, Exchange;
  privateFoo = {};
  Exchange = (function(){
    Exchange.displayName = 'Exchange';
    var self, library, modules, prototype = Exchange.prototype, constructor = Exchange;
    self = null;
    library = null;
    modules = null;
    function Exchange(cb, _library){
      self = this;
      self.type = 7;
      library = _library;
      cb(null, self);
    }
    Exchange.prototype.create = function(data, trs){
      trs.asset = {
        sell_token: data.sell_token,
        buy_token: data.buy_token,
        price: data.price,
        amount: data.amount
      };
      return trs;
    };
    Exchange.prototype.calculateFee = function(trs){
      return 0;
    };
    Exchange.prototype.verify = function(trs, sender, cb, scope){
      setImmediate(cb, null, trs);
    };
    Exchange.prototype.getBytes = function(trs){
      var buf, e;
      console.log(trs);
      try {
        buf = new Buffer(trs.asset.sell_token + trs.asset.buy_token + trs.asset.price + trs.asset.amount, "utf8");
      } catch (e$) {
        e = e$;
        throw Error(e.toString());
      }
      return buf;
    };
    Exchange.prototype.apply = function(trs, sender, cb, scope){
      modules.blockchain.accounts.mergeAccountAndGet({
        address: sender.address,
        balance: {
          LISK: -trs.fee
        }
      }, cb);
    };
    Exchange.prototype.undo = function(trs, sender, cb, scope){
      modules.blockchain.accounts.undoMerging({
        address: sender.address,
        balance: {
          LISK: -trs.fee
        }
      }, cb);
    };
    Exchange.prototype.applyUnconfirmed = function(trs, sender, cb, scope){
      if (sender.u_balance < trs.fee) {
        return setImmediate(cb, 'Sender doesn\'t have enough coins');
      }
      modules.blockchain.accounts.mergeAccountAndGet({
        address: sender.address,
        u_balance: {
          LISK: -trs.fee
        }
      }, cb);
    };
    Exchange.prototype.undoUnconfirmed = function(trs, sender, cb, scope){
      modules.blockchain.accounts.undoMerging({
        address: sender.address,
        u_balance: {
          LISK: -trs.fee
        }
      }, cb);
    };
    Exchange.prototype.ready = function(trs, sender, cb, scope){
      setImmediate(cb);
    };
    Exchange.prototype.save = function(trs, cb){
      console.log('saving!!!', trs);
      modules.api.sql.insert({
        table: 'asset_buy_orders',
        values: {
          transactionId: trs.id,
          sell_token: trs.asset.sell_token,
          buy_token: trs.asset.buy_token,
          price: trs.asset.price,
          amount: trs.asset.amount
        }
      }, cb);
    };
    Exchange.prototype.dbRead = function(row){
      if (!row.buys_transactionId) {
        return null;
      } else {
        return {
          sell_token: row.buy_sell_token,
          buy_token: row.buy_buy_token,
          price: row.buy_price,
          amount: row.buy_amount
        };
      }
    };
    Exchange.prototype.normalize = function(asset, cb){
      return setImmediate(cb);
      return library.validator.validate(asset, {
        type: 'object',
        properties: {
          sell_token: {
            type: 'string',
            format: 'hex',
            minLength: 1
          },
          buy_token: {
            type: 'string',
            format: 'hex',
            minLength: 1
          }
        },
        required: ['sell_token', 'buy_token']
      }, function(e, r){
        console.log(e, r);
        return cb(e, r);
      });
    };
    Exchange.prototype.onBind = function(_modules){
      modules = _modules;
      modules.logic.transaction.attachAssetType(self.type, self);
    };
    Exchange.prototype.transfer = function(cb, query){
      var keypair;
      keypair = modules.api.crypto.keypair(query.secret);
      modules.blockchain.accounts.setAccountAndGet({
        publicKey: keypair.publicKey.toString('hex')
      }, function(err, account){
        var transaction, e;
        try {
          transaction = library.modules.logic.transaction.create({
            type: 1,
            sender: account,
            keypair: keypair,
            recipientId: '14897368726134874721L',
            amount: 1000000,
            src_id: '15644840914319835157'
          });
        } catch (e$) {
          e = e$;
          return setImmediate(cb, e.toString());
        }
        return modules.blockchain.transactions.processUnconfirmedTransaction(transaction, cb);
      });
    };
    Exchange.prototype.createBuyOrder = function(cb, query){
      console.log(query, 'asldkjhalsjkdh');
      library.validator.validate(query, {
        type: 'object',
        properties: {
          secret: {
            type: 'string',
            minLength: 1,
            maxLength: 100
          },
          buy_token: {
            type: 'string',
            minLength: 1,
            maxLength: 42
          },
          sell_token: {
            type: 'string',
            minLength: 1,
            maxLength: 42
          },
          price: {
            type: 'integer',
            minLength: 1,
            maxLength: 42
          },
          amount: {
            type: 'integer',
            minLength: 1,
            maxLength: 42
          }
        }
      }, function(err){
        var keypair;
        console.log(1111111111111111);
        if (err) {
          console.log(2222222222222);
          console.log(err);
          return cb(err[0].message);
        }
        keypair = modules.api.crypto.keypair(query.secret);
        modules.blockchain.accounts.setAccountAndGet({
          publicKey: keypair.publicKey.toString('hex')
        }, function(err, account){
          var transaction, e;
          if (err) {
            console.log(333333333333);
            return cb(err);
          }
          console.log({
            type: self.type,
            sell_token: query.sell_token,
            buy_token: query.buy_token,
            amount: query.amount,
            price: query.price,
            sender: account,
            keypair: keypair
          });
          console.log(999999999999);
          try {
            transaction = library.modules.logic.transaction.create({
              type: self.type,
              sell_token: query.sell_token,
              buy_token: query.buy_token,
              price: query.price,
              amount: query.amount,
              sender: account,
              keypair: keypair
            });
          } catch (e$) {
            e = e$;
            console.log(4444444444);
            return setImmediate(cb, e.toString());
          }
          modules.blockchain.transactions.processUnconfirmedTransaction(transaction, cb);
        });
      });
    };
    Exchange.prototype.hyper = function(cb, query){
      modules.blockchain.accounts.getAccount({
        address: '14897368726134874721L'
      }, function(e, r){
        console.log(query);
        return cb(e, r);
      });
    };
    Exchange.prototype.getPublicAccounts = function(cb, query){};
    Exchange.prototype.getBuyWall = function(cb){
      return modules.api.sql.select({
        table: 'asset_buy_orders'
      }, null, function(err, transactions){
        var homeValues;
        if (err) {
          return cb(err.toString());
        }
        console.log(transactions);
        homeValues = transactions.map(function(tx){
          return tx;
        });
        return cb(null, {
          homeValues: homeValues
        });
      });
    };
    return Exchange;
  }());
  module.exports = Exchange;
}).call(this);
